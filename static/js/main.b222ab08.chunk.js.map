{"version":3,"sources":["logo.svg","SortingVisualizer/MergeSort.jsx","SortingVisualizer/InsertionSort.jsx","SortingVisualizer/BubbleSort.jsx","SortingVisualizer/QuickSort.jsx","SortingVisualizer/Heap.jsx","SortingVisualizer/AnimationHandlers.jsx","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","getAnimations","array","animations","mergeSort","first","last","mid","Math","floor","startId","midId","endId","firstHalf","i","push","secondHalf","j","firstCounter","secondCounter","mainCounter","length","merge","getAnimationsI","Array","pivot","insertionSort","getAnimationsBubble","lastUnordered","bubbleSort","getAnimationsQS","quickSort","lower","higher","p","aux","partition","maxHeapify","index","arraysize","largest","left","right","getAnimationsHeap","temp","constructMaxHeap","heapSort","console","log","animationHandler","bars","animation","speed","color","secondColor","restoreColor","finalColor","barOneStyle","style","setTimeout","backgroundColor","barTwoId","barTwoStyle","newHeight","height","barOneId","barOneHeight","barTwoHeight","COLOR","FINAL_COLOR","SortingVisualizer","props","state","numberOfBars","ANIM_SPEED","sliderHandler","bind","speedHandler","this","resetArray","document","getElementsByClassName","randomBetween","setState","resetColor","disableButtons","enableButtons","toString","event","value","target","getElementById","disabled","max","min","round","random","className","map","id","key","width","class","type","onChange","onClick","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b222ab08.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react'\r\n// Function that calls mergeSort and returns an array of animations\r\nexport function getAnimations(array) {\r\n    const animations = [];\r\n    mergeSort(array,0, array.length - 1, animations);\r\n    return animations;\r\n}\r\n\r\nexport function merge (array, startId, midId, endId, animations) {\r\n    // We copy the first half of the array on an empty array \r\n    let firstHalf = [];\r\n    for (let i = startId; i <= midId; i++) {\r\n        firstHalf.push(array[i]);\r\n    }\r\n    // we copy the second half of the array on an empty array\r\n    let secondHalf = [];\r\n    for (let j = midId + 1; j <= endId; j++) {\r\n        secondHalf.push(array[j]);\r\n    }\r\n    // We initiate first and secondcounters to 0, to go throught both copies made in the previous steps.\r\n    // Maincounter is the counter of the original array. We initiate it with firstId\r\n    let firstCounter = 0;\r\n    let secondCounter = 0 ;\r\n    let mainCounter = startId;\r\n    // We compare each the items from the copies to see which one is smaller, and place it on the original array\r\n    while (firstCounter < firstHalf.length && secondCounter < secondHalf.length) {\r\n        // The 'compare' animation takes the bars that are being compared and highlights them. Then we restore it\r\n        // to the origianl color ('restore' tag)\r\n        // When the endId we recieve equals the original array length and startId equals 0, it means that we are \r\n        // starting the last merge, which means that the numbers are being placed in their final position. We pass\r\n        // this information with the 'final' tag and paint the bars in a final sorted color\r\n        animations.push(['compare', mainCounter, midId + 1 + secondCounter ]);\r\n        animations.push(['restore', mainCounter, midId + 1 + secondCounter ]);\r\n        if (firstHalf[firstCounter] <= secondHalf[secondCounter]) {\r\n            if (endId === array.length - 1 && startId === 0) {\r\n                animations.push(['finalmerge', mainCounter, firstHalf[firstCounter]]);\r\n            } else {\r\n                animations.push(['swap', mainCounter, firstHalf[firstCounter] ]);\r\n            }\r\n            array[mainCounter] = firstHalf[firstCounter];\r\n            mainCounter ++;\r\n            firstCounter ++;\r\n        } else {\r\n            if (endId === array.length - 1 && startId === 0) {\r\n                animations.push(['finalmerge', mainCounter, secondHalf[secondCounter]]);\r\n            } else {\r\n                animations.push(['swap', mainCounter, secondHalf[secondCounter]]);\r\n            }\r\n            array[mainCounter] = secondHalf[secondCounter];\r\n            mainCounter ++;\r\n            secondCounter ++;\r\n        }\r\n    }\r\n    // Once one of the halves is empty, we go through the other and place each remaining number \r\n    // on the array\r\n    while (firstCounter < firstHalf.length) {\r\n        animations.push(['compare', mainCounter, mainCounter]);\r\n        if (endId === array.length - 1 && startId === 0) {\r\n            animations.push(['finalmerge', mainCounter, firstHalf[firstCounter]])\r\n        } else {\r\n            animations.push(['swap', mainCounter, firstHalf[firstCounter]])\r\n            animations.push(['restore', mainCounter, mainCounter]);\r\n        }\r\n        \r\n        array[mainCounter] = firstHalf[firstCounter];\r\n        mainCounter ++;\r\n        firstCounter ++;\r\n    }\r\n\r\n    while (secondCounter < secondHalf.length) {\r\n        animations.push(['compare', midId + 1 + secondCounter, midId + 1 +secondCounter]);\r\n        if (endId === array.length - 1 && startId === 0) {\r\n            animations.push(['finalmerge', mainCounter, secondHalf[secondCounter]]);\r\n        } else {\r\n            animations.push(['swap', mainCounter, secondHalf[secondCounter]]);\r\n            animations.push(['restore', midId + 1 + secondCounter, midId + 1 + secondCounter]);\r\n        }\r\n        \r\n        array[mainCounter] = secondHalf[secondCounter];\r\n        mainCounter ++;\r\n        secondCounter ++;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nexport function mergeSort(\r\n    array,\r\n    first,\r\n    last,\r\n    animations,\r\n) {\r\n    // Merge sort divides the original array in two halves recursively and then merges them when they are sorted\r\n    // When the first id equals  the last id, it means we have reached halves of size 1. By definition an array of\r\n    // size 1 is sorted, so we start merging. Since merge returns a sorted array given two sorted arrays,\r\n    // once we finish the recursive calls we have sorted the original array.\r\n\r\n\r\n    // we check to return when first and last ids are equal, to return and avoid an infinite loop\r\n    if (first === last) return\r\n    // We \"divide\" the array in two by getting the mid ID and calling mergeSort with midID as the first item \r\n    // and the last item\r\n    const mid = Math.floor((first + last) / 2)\r\n    mergeSort(array, first, mid, animations)\r\n    mergeSort(array, mid +1 , last, animations)\r\n    merge(array, first, mid , last, animations )\r\n    \r\n\r\n\r\n}\r\nexport default getAnimations ","import React from 'react'\r\n\r\nexport function getAnimationsI(array) {\r\n    const animations = new Array();\r\n    insertionSort(array, animations);\r\n    return animations;\r\n}\r\n\r\nexport function insertionSort(array, animations) {\r\n    let j; \r\n\r\n    for (let i = 1; i < array.length; i++) {\r\n        j = i;\r\n        let pivot; \r\n        while (j > 0 && (array[j] < array[j-1])) {\r\n            if (j <= i) {\r\n                animations.push(['compare', j, j-1,])\r\n                animations.push(['restore', j, j-1, 'finalcolor'])\r\n                animations.push(['swap', j, array[j-1]])\r\n                animations.push(['swap', j-1, array[j]])\r\n                animations.push(['final', j, array[j-1]])\r\n                animations.push(['final', j-1, array[j]])\r\n            } else {\r\n                animations.push(['compare', j, j-1])\r\n                animations.push(['restore', j, j-1, 'color']);\r\n            }\r\n            \r\n            pivot = array[j];\r\n            array[j] = array[j-1];\r\n            array[j-1] = pivot;\r\n            j--;\r\n        }\r\n    }\r\n}\r\n\r\nexport default getAnimationsI","import React from 'react'\r\n\r\nexport function getAnimationsBubble(array) {\r\n    const animations = new Array();\r\n    animations.push([0,0])\r\n    bubbleSort(array, animations);\r\n    return animations;\r\n}\r\n// Bubble sort uses 2 nested loops, it always starts on the first element and compares it with the next element.\r\n// If it is bigger it swaps. Swap or not it keeps going through the array.\r\n// On each iteration of the outer loop, we get the biggest element on the array.\r\nfunction bubbleSort(array, animations) {\r\n    let pivot;\r\n    let lastUnordered = array.length - 1; // The index of the last non-ordered element in the array. \r\n    for(let j = 0; j < array.length; j++) {\r\n        for(let i = 0; i < array.length; i++) {\r\n            if(array[i] > array[i + 1]) {\r\n                animations.push(['compare', i, i + 1])\r\n                animations.push(['restore', i, i + 1])\r\n                animations.push(['swap', i, array[i + 1]])\r\n                animations.push(['swap', i + 1, array[i]]) \r\n                pivot = array[i];\r\n                array[i] = array[i + 1];\r\n                array[i + 1] = pivot;\r\n            }\r\n        }\r\n        animations.push(['final',lastUnordered]); // Here we paint the the bar in its final place and decrease the index\r\n        lastUnordered -- ;\r\n    }\r\n}\r\n\r\nexport default getAnimationsBubble","import React from 'react'\r\n\r\nexport function getAnimationsQS(array) {\r\n    const animations = new Array();\r\n    quickSort(array,0,array.length - 1, animations);\r\n    return animations;\r\n    \r\n}\r\n\r\nexport function quickSort(array, lower, higher, animations) {\r\n    if (lower <= higher) {\r\n        const p = partition(array, lower, higher, animations);\r\n        quickSort(array, lower, p - 1, animations);\r\n        quickSort(array, p + 1, higher, animations);\r\n    }\r\n\r\n}\r\n\r\nexport function partition(array, lower, higher,animations) {\r\n    const pivot = array[higher];\r\n    animations.push(['pivot', higher])\r\n    let i = lower - 1;\r\n    let aux;\r\n    for (let j = lower; j <= higher - 1; j++) {\r\n        if(array[j] <= pivot) {\r\n            animations.push(['compare',j, higher]);\r\n            animations.push(['restore',j, higher]);\r\n            i++;\r\n            animations.push(['swap',j, array[i]]);\r\n            animations.push(['swap',i, array[j]]);\r\n            aux = array[i];\r\n            array[i] = array[j];\r\n            array[j] = aux;\r\n            \r\n        }\r\n    }\r\n\r\n    animations.push(['pivotswap',higher, array[i+1]])\r\n    animations.push(['pivotswap',i+1, array[higher]])\r\n    aux = array[higher];\r\n    array[higher] = array[i+1];\r\n    array[i+1] = aux;\r\n    return i + 1;\r\n    \r\n}\r\n\r\n\r\n\r\nexport default getAnimationsQS\r\n\r\n","import React from 'react'\r\n\r\n\r\nfunction getAnimationsHeap(array) {\r\n    const animations = new Array();\r\n    heapSort(array, array.length , animations)\r\n    console.log(animations)\r\n    return animations;\r\n}\r\n\r\nexport function heapSort(array, arraysize, animations) {\r\n    let temp;\r\n    constructMaxHeap(array, arraysize, animations); // Turns the given array into a maxHeap\r\n    for (let i = arraysize - 1 ; i >= 0; i--) {\r\n        animations.push(['lastswap', 0, array[i], i, array[0]]);\r\n        temp = array[0];\r\n        array[0] = array[i]; //Pushes the first element, which is the biggest one, to the last array position\r\n        array[i] = temp;\r\n        arraysize--;         // Decreases the arraysize so we don't take into account the largest item\r\n        maxHeapify(array, 0, arraysize, animations);       // Calling maxHeapify we get the largest item on 1st index\r\n        \r\n    }\r\n     \r\n\r\n}\r\n// Calls maxHeapify from middle index to 1\r\n// The second half are all leaves, which are maxHeaps by definition\r\n\r\nexport function constructMaxHeap(array, arraysize, animations) {\r\n        for (let i = Math.floor(arraysize - 1 / 2); i >= 0; i--) {\r\n                maxHeapify(array, i, arraysize, animations);\r\n\r\n        }        \r\n}\r\n\r\n       \r\n\r\nfunction maxHeapify(array, index, arraysize, animations) {\r\n    let largest;\r\n    let left = index * 2 + 1;\r\n    let right = index * 2 + 2 < arraysize ? index * 2 + 2 : null ;\r\n\r\n\r\n    if (left < arraysize) {\r\n        animations.push(['compare', left, index])\r\n        animations.push(['restore', left, index])\r\n    }\r\n\r\n    if (left < arraysize && array[left] > array[index]) {\r\n        largest = left\r\n        \r\n    } else largest = index;\r\n    \r\n    if (right < arraysize && right !== null) {\r\n        animations.push(['compare', right, largest])\r\n        animations.push(['restore', right, largest])\r\n    }\r\n    if (right < arraysize && array[right] > array[largest]) {\r\n        largest = right;\r\n    }\r\n    \r\n    if (largest !== index) {\r\n        animations.push(['heapswap', index, array[largest], largest, array[index]])\r\n        let aux = array[largest]\r\n        array[largest] = array[index];\r\n        array[index] = aux;\r\n        // We call maxHeapify recursively since we may alter the maxHeap in between swaps\r\n        maxHeapify(array, largest, arraysize, animations);\r\n    }\r\n\r\n}\r\n\r\n\r\n        \r\nexport default getAnimationsHeap\r\n\r\n\r\n    ","import React from 'react'\r\n\r\nfunction animationHandler(bars, animation, speed, color, secondColor, restoreColor, finalColor) {\r\n    if(animation[0] === 'pivot') {\r\n        const barOneId = animation[1];\r\n        const barOneStyle = bars[barOneId].style;\r\n        setTimeout(()=> {\r\n            barOneStyle.backgroundColor = \"gold\";\r\n        }, speed)\r\n        \r\n    }  else if(animation[0] === 'compare' || animation[0] === 'restore') { \r\n            const [barOneId, barTwoId] = [animation[1], animation[2]]\r\n            const barOneStyle = bars[barOneId].style;\r\n            const barTwoStyle = bars[barTwoId].style;\r\n            setTimeout(() => {\r\n                barOneStyle.backgroundColor = animation[0] === 'compare' ? secondColor : color\r\n                barTwoStyle.backgroundColor = animation[0] === 'compare' ? secondColor : restoreColor\r\n                } , speed )\r\n                 \r\n    } else if(animation[0] === 'swap') {\r\n            const [barOneId, newHeight] = [animation[1],animation[2]];\r\n            const barOneStyle = bars[barOneId].style;\r\n            setTimeout(() => {\r\n            barOneStyle.height = `${newHeight}px`;\r\n            }, speed)\r\n        } else if (animation[0] === 'pivotswap') {\r\n            const [barOneId, newHeight] = [animation[1],animation[2]];\r\n            const barOneStyle = bars[barOneId].style;\r\n            setTimeout(() => {\r\n            barOneStyle.height = `${newHeight}px`;\r\n            if(barOneStyle.backgroundColor === \"black\") {\r\n                barOneStyle.backgroundColor = color;\r\n            } else {\r\n                barOneStyle.backgroundColor = finalColor;\r\n            }\r\n             }, speed)\r\n        } else if (animation[0] === 'final') {\r\n\r\n            const barOneId = animation[1]\r\n            const barOneStyle = bars[barOneId].style;\r\n            setTimeout(()=> {\r\n                barOneStyle.backgroundColor = finalColor;\r\n\r\n            }, speed)\r\n        } else if (animation[0] === 'finalmerge') {\r\n\r\n            const [barOneId, newHeight] = [animation[1], animation[2]];\r\n            const barOneStyle = bars[barOneId].style;\r\n            setTimeout(() => {\r\n                barOneStyle.height = `${newHeight}px`;\r\n                barOneStyle.backgroundColor = finalColor;\r\n            }, speed);\r\n        } else if (animation[0] === 'lastswap') {\r\n            const [barOneId, barOneHeight] = [animation[1], animation[2]]\r\n            const [barTwoId, barTwoHeight] = [animation[3], animation[4]]\r\n            const barOneStyle = bars[barOneId].style\r\n            const barTwoStyle = bars[barTwoId].style\r\n            setTimeout(() => {\r\n                barOneStyle.height = `${barOneHeight}px`\r\n                barTwoStyle.height = `${barTwoHeight}px`\r\n                barTwoStyle.backgroundColor = finalColor;\r\n            }, speed)\r\n        } else if (animation[0] === 'heapswap') { \r\n            const [barOneId, barOneHeight] = [animation[1], animation[2]]\r\n            const [barTwoId, barTwoHeight] = [animation[3], animation[4]]\r\n            const barOneStyle = bars[barOneId].style\r\n            const barTwoStyle = bars[barTwoId].style\r\n            setTimeout(() => {\r\n                barOneStyle.height = `${barOneHeight}px`\r\n                barTwoStyle.height = `${barTwoHeight}px`\r\n            }, speed)\r\n\r\n        }\r\n\r\n}\r\n\r\nexport default animationHandler","import React from 'react';\r\nimport './SortingVisualizer.css';\r\nimport getAnimations from './MergeSort.jsx'\r\nimport getAnimationsI from './InsertionSort.jsx'\r\nimport getAnimationsBubble from './BubbleSort.jsx'\r\nimport getAnimationsQS from './QuickSort.jsx';\r\nimport  getAnimationsHeap from './Heap.jsx'\r\nimport animationHandler from './AnimationHandlers';\r\n\r\nconst COLOR = \"white\";\r\nconst SECOND_COLOR = \"deeppink\";\r\nconst FINAL_COLOR = 'rgb(0, 221, 129)';\r\nlet running = false;\r\n\r\nclass SortingVisualizer extends React.Component {\r\n    \r\n    constructor(props) \r\n    {   \r\n        \r\n        super(props);\r\n\r\n        this.state = {\r\n         array: [],\r\n         numberOfBars: 150,\r\n         ANIM_SPEED: 3,\r\n        } ;\r\n       \r\n        this.sliderHandler = this.sliderHandler.bind(this);\r\n        this.speedHandler = this.speedHandler.bind(this);\r\n}\r\n    componentDidMount() {\r\n        this.resetArray(this.state.numberOfBars);\r\n\r\n    }\r\n\r\n    resetColor() {\r\n        const bars = document.getElementsByClassName(\"array-bar\");\r\n        for (let i = 0; i < bars.length; i++) {\r\n            bars[i].style.backgroundColor = COLOR;\r\n        }\r\n    }\r\n\r\n    resetArray(numberOfBars) {\r\n        const array = [];\r\n        for (let i = 0; i < numberOfBars; i++) {\r\n            array.push(this.randomBetween(20, 550));\r\n        }\r\n        this.setState({array});\r\n        this.resetColor();\r\n        \r\n        \r\n    }\r\n\r\n\r\n    mergeSort() {   \r\n        this.disableButtons();\r\n        let totalTime = 0;\r\n        const animations = getAnimations(this.state.array);\r\n        const bars = document.getElementsByClassName(\"array-bar\");\r\n        for (let i = 0; i < animations.length; i++) {\r\n            \r\n            animationHandler(bars, animations[i], i * this.state.ANIM_SPEED, COLOR, SECOND_COLOR, COLOR, FINAL_COLOR)\r\n\r\n        }\r\n        setTimeout(this.enableButtons, this.state.ANIM_SPEED * animations.length)\r\n    }\r\n\r\n    insertionSort() {\r\n        this.disableButtons();\r\n        const animations = getAnimationsI(this.state.array);\r\n        const bars = document.getElementsByClassName(\"array-bar\");\r\n        for (let i = 1; i < animations.length; i++) {\r\n            \r\n            animationHandler(bars, animations[i], i * this.state.ANIM_SPEED, COLOR, SECOND_COLOR, FINAL_COLOR, FINAL_COLOR);\r\n        \r\n        }  \r\n        setTimeout(this.enableButtons, this.state.ANIM_SPEED * animations.length)\r\n\r\n    }\r\n\r\n    bubbleSort() {\r\n        this.disableButtons();\r\n        console.log(running.toString())\r\n        const animations = getAnimationsBubble(this.state.array);\r\n        const bars = document.getElementsByClassName(\"array-bar\");\r\n        for (let i = 1; i < animations.length; i++) {\r\n            \r\n            animationHandler(bars, animations[i], i * this.state.ANIM_SPEED, COLOR, SECOND_COLOR, COLOR, FINAL_COLOR);\r\n       \r\n        } \r\n        setTimeout(this.enableButtons, this.state.ANIM_SPEED * animations.length)\r\n    }\r\n    quickSort() {\r\n        this.disableButtons();\r\n        const animations = getAnimationsQS(this.state.array);\r\n        const bars = document.getElementsByClassName(\"array-bar\");   \r\n        for (let i = 0; i < animations.length; i++) {\r\n            \r\n            animationHandler(bars, animations[i], i * this.state.ANIM_SPEED, COLOR, SECOND_COLOR, 'gold', FINAL_COLOR);\r\n\r\n        }\r\n        setTimeout(this.enableButtons, this.state.ANIM_SPEED * animations.length)\r\n    }\r\n\r\n    heapSort() {\r\n        this.disableButtons();\r\n        const animations = getAnimationsHeap(this.state.array)\r\n        const bars = document.getElementsByClassName(\"array-bar\");\r\n        for (let i = 0; i < animations.length; i++) {\r\n            \r\n            animationHandler(bars, animations[i], i * this.state.ANIM_SPEED, COLOR, SECOND_COLOR, COLOR, FINAL_COLOR)\r\n\r\n        }\r\n        setTimeout(this.enableButtons, this.state.ANIM_SPEED * animations.length)\r\n    }\r\n\r\n    sliderHandler(event) {\r\n        const value = event.target.value\r\n        this.resetArray(value);\r\n\r\n    }\r\n    speedHandler(event) {\r\n        const value = event.target.value;\r\n        this.setState({ANIM_SPEED: value});\r\n    }\r\n\r\n    disableButtons() {\r\n        document.getElementById(\"mergeSort\").disabled = true;\r\n        document.getElementById(\"insertionSort\").disabled = true;\r\n        document.getElementById(\"quickSort\").disabled = true;\r\n        document.getElementById(\"heapSort\").disabled = true;\r\n        document.getElementById(\"bubbleSort\").disabled = true;\r\n        document.getElementById(\"newArray\").disabled = true;\r\n        document.getElementById(\"speedbar\").disabled = true;\r\n        document.getElementById(\"arraybar\").disabled = true;\r\n        \r\n    }\r\n\r\n    enableButtons() {\r\n        document.getElementById(\"mergeSort\").disabled = false\r\n        document.getElementById(\"insertionSort\").disabled = false;\r\n        document.getElementById(\"quickSort\").disabled = false\r\n        document.getElementById(\"heapSort\").disabled = false\r\n        document.getElementById(\"bubbleSort\").disabled = false\r\n        document.getElementById(\"newArray\").disabled = false\r\n        document.getElementById(\"speedbar\").disabled = false;\r\n        document.getElementById(\"arraybar\").disabled = false;\r\n    }\r\n\r\n    randomBetween(max, min) {\r\n        return Math.round(Math.random() * (max - min) + min);\r\n    }\r\n\r\n    render() {\r\n        let array = this.state.array;\r\n        return (\r\n        <div>\r\n            <div className=\"bar-container\">\r\n             {array.map((value, id) => (\r\n                    <div\r\n                        className=\"array-bar\"\r\n                        key={id}\r\n                        style={{\r\n                        backgroundColor: COLOR,\r\n                        height: `${value}px`,\r\n                        width: '20px'\r\n                    }}> \r\n                    </div>\r\n            )\r\n            )}\r\n            </div> \r\n            <div id=\"toolbar\">\r\n                <div id=\"sliders\">\r\n                    <div id=\"slider\"> <p>Change array size</p>\r\n                    <input class=\"slider\" id=\"arraybar\" disabled={running ? \"true\" : null} type=\"range\" min=\"20\" max=\"300\" value={this.state.array.length} onChange={this.sliderHandler} />\r\n                </div>\r\n                <div id=\"slider\"> <p>Change animation speed</p>\r\n                    <input class=\"slider\" id=\"speedbar\" disabled={running ? \"true\" : null} type=\"range\" min=\"1\" max=\"300\" value={this.state.ANIM_SPEED} onChange={this.speedHandler} />\r\n                </div>\r\n                </div>\r\n                <div id=\"buttons\">\r\n                    <button class=\"algobutton\" id=\"newArray\" disabled={running ? \"true\" : null} onClick={() => this.resetArray(document.getElementById(\"arraybar\").value)} >New array</button>\r\n                    <button class=\"algobutton\" id=\"mergeSort\" disabled={running ? \"true\" : null} onClick={() => this.mergeSort()} >Merge Sort</button>\r\n                    <button class=\"algobutton\" id=\"insertionSort\" disabled={running ? \"true\" : null} onClick={() => this.insertionSort()} >Insertion Sort</button>\r\n                    <button class=\"algobutton\" id=\"bubbleSort\" disabled={running ? \"true\" : null} onClick={() => this.bubbleSort()} >Bubble Sort</button>\r\n                    <button class=\"algobutton\" id=\"quickSort\" disabled={running ? \"true\" : null} onClick={() => this.quickSort()} >Quick Sort</button>\r\n                    <button class=\"algobutton\" id=\"heapSort\" disabled={running ? \"true\" : null} onClick={() => this.heapSort()} >Heap Sort</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default SortingVisualizer","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer.jsx'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}